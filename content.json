{"meta":{"title":"sgclzqq","subtitle":"为你，千千万万遍！","description":"Unity踩坑人","author":"sgclzqq","url":"http://sgclzqq.com"},"pages":[{"title":"分类","date":"2014-12-22T04:39:04.000Z","updated":"2018-04-17T14:16:07.247Z","comments":false,"path":"categories/index.html","permalink":"http://sgclzqq.com/categories/index.html","excerpt":"","text":""},{"title":"关于","date":"2014-12-22T04:39:04.000Z","updated":"2018-04-17T14:37:30.254Z","comments":false,"path":"about/index.html","permalink":"http://sgclzqq.com/about/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2018-04-17T14:52:08.774Z","updated":"2018-04-17T14:52:08.774Z","comments":true,"path":"links/index.html","permalink":"http://sgclzqq.com/links/index.html","excerpt":"","text":"M-finder: http://www.m-finder.com/ AprilBlank: http://www.aprilblank.com/ 魔都大白: https://blog.csdn.net/qq_27948659/ 大槐树: https://www.yyblogs.net/ 小潘: https://ghostcto.coding.me/ Wait: https://93xiaosi.github.io/"},{"title":"标签","date":"2014-12-22T04:39:04.000Z","updated":"2018-04-17T14:14:59.263Z","comments":false,"path":"tags/index.html","permalink":"http://sgclzqq.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"test","slug":"test","date":"2018-04-17T13:40:13.000Z","updated":"2018-04-17T14:08:01.968Z","comments":true,"path":"2018/04/17/test/","link":"","permalink":"http://sgclzqq.com/2018/04/17/test/","excerpt":"","text":"ggsgsfdg","categories":[{"name":"测试","slug":"测试","permalink":"http://sgclzqq.com/categories/测试/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"http://sgclzqq.com/tags/Unity/"}]},{"title":"Unity组件本地映射","slug":"Unity组件本地映射","date":"2018-04-09T12:41:32.000Z","updated":"2018-04-17T15:37:14.286Z","comments":true,"path":"2018/04/09/Unity组件本地映射/","link":"","permalink":"http://sgclzqq.com/2018/04/09/Unity组件本地映射/","excerpt":"TextMesh组件本地映射 Light组件本地映射 通过JsonNet插件将Unity组件的属性值保存到本地的Json文件中，便于重新加载数据，恢复组件属性值，达到保存组件状态的目标。","text":"TextMesh组件本地映射 Light组件本地映射 通过JsonNet插件将Unity组件的属性值保存到本地的Json文件中，便于重新加载数据，恢复组件属性值，达到保存组件状态的目标。 TextMesh组件本地映射TextMesh本地映射 public JToken GenerateJToken(Component component) { TextMesh e = component as TextMesh; if (!e) return null; JObject jo = new JObject(); jo.Add(&quot;type&quot;, typeof(TextMesh).FullName); jo.Add(&quot;text&quot;, e.text); jo.Add(&quot;offsetZ&quot;, e.offsetZ); jo.Add(&quot;characterSize&quot;, e.characterSize); jo.Add(&quot;lineSpacing&quot;, e.lineSpacing); jo.Add(&quot;anchor&quot;, (int) e.anchor); jo.Add(&quot;alignment&quot;, (int)e.alignment); jo.Add(&quot;tabSize&quot;, e.tabSize); jo.Add(&quot;fontSize&quot;, e.fontSize); jo.Add(&quot;fontStyle&quot;, (int)e.fontStyle); jo.Add(&quot;richText&quot;, e.richText); var color = e.color; var colorStr = string.Format(&quot;{0},{1},{2},{3}&quot;, color.r, color.g, color.b, color.a); jo.Add(&quot;color&quot;, colorStr); return jo; } TextMesh加载恢复 public void ApplyJToken(Component component, JToken jt) { TextMesh e = component as TextMesh; if (!e) return; e.text = (string) jt[&quot;text&quot;]; e.offsetZ = (float) jt[&quot;offsetZ&quot;]; e.characterSize = (float) jt[&quot;characterSize&quot;]; e.lineSpacing = (float) jt[&quot;lineSpacing&quot;]; e.anchor=(TextAnchor)(int)jt[&quot;anchor&quot;]; e.alignment = (TextAlignment) (int) jt[&quot;alignment&quot;]; e.tabSize = (float) jt[&quot;tabSize&quot;]; e.fontSize = (int) jt[&quot;fontSize&quot;]; e.fontStyle = (FontStyle) (int) jt[&quot;fontStyle&quot;]; e.richText = (bool) jt[&quot;richText&quot;]; FrameCount.CountdownCallBack(1, () =&gt; { e.font = Font.CreateDynamicFontFromOSFont(&quot;Arial&quot;, 12); if (e.font != null) e.transform.GetComponent&lt;MeshRenderer&gt;().sharedMaterial = e.font.material; }); var colorStr= (string)jt[&quot;color&quot;]; string[] str = colorStr.Split(&#39;,&#39;); Color color = new Color(float.Parse(str[0]), float.Parse(str[1]), float.Parse(str[2]), float.Parse(str[3])); e.color = color; } Light组件本地映射Light本地映射 public JToken GenerateJToken(Component component) { Light e = component as Light; if (!e) return null; JObject jo = new JObject(); jo.Add(&quot;type&quot;, typeof(Light).FullName); jo.Add(&quot;lightType&quot;, (int) e.type); if (e.type == LightType.Point || e.type == LightType.Spot) { jo.Add(&quot;range&quot;, e.range); } if (e.type == LightType.Spot) { jo.Add(&quot;spotAngle&quot;, e.spotAngle); } var color = e.color; var colorStr = string.Format(&quot;{0},{1},{2},{3}&quot;, color.r, color.g, color.b, color.a); jo.Add(&quot;color&quot;, colorStr); jo.Add(&quot;intensity&quot;, (float) e.intensity); jo.Add(&quot;shadowType&quot;, (int) e.shadows); jo.Add(&quot;strength&quot;, e.shadowStrength); jo.Add(&quot;shadowResolution&quot;, (int) e.shadowResolution); jo.Add(&quot;bias&quot;, e.shadowBias); jo.Add(&quot;normalBias&quot;, e.shadowNormalBias); jo.Add(&quot;nearPlane&quot;, e.shadowNearPlane); jo.Add(&quot;renderMode&quot;, (int)e.renderMode); jo.Add(&quot;mask&quot;, (int) e.cullingMask); return jo; } Light属性恢复 public void ApplyJToken(Component component, JToken jt) { Light e = component as Light; if (!e) return; e.type = (LightType)(int)jt[&quot;lightType&quot;]; if (e.type == LightType.Point || e.type == LightType.Spot) { e.range = (float)jt[&quot;range&quot;]; } if (e.type == LightType.Spot) { e.spotAngle = (float) jt[&quot;spotAngle&quot;]; } var colorStr = (string)jt[&quot;color&quot;]; string[] str = colorStr.Split(&#39;,&#39;); Color color = new Color(float.Parse(str[0]), float.Parse(str[1]), float.Parse(str[2]), float.Parse(str[3])); e.color = color; e.intensity = (float) jt[&quot;intensity&quot;]; e.shadows = (LightShadows) (int) jt[&quot;shadowType&quot;]; e.shadowStrength = (float) jt[&quot;strength&quot;]; e.shadowResolution = (LightShadowResolution)(int) jt[&quot;shadowResolution&quot;]; e.shadowBias = (float) jt[&quot;bias&quot;]; e.shadowNormalBias = (float) jt[&quot;normalBias&quot;]; e.shadowNearPlane = (float) jt[&quot;nearPlane&quot;]; e.renderMode = (LightRenderMode) (int) jt[&quot;renderMode&quot;]; e.cullingMask = (int) jt[&quot;mask&quot;]; }","categories":[],"tags":[{"name":"Unity笔记","slug":"Unity笔记","permalink":"http://sgclzqq.com/tags/Unity笔记/"}]},{"title":"unity笔记","slug":"unity笔记","date":"2018-03-14T05:57:17.000Z","updated":"2018-04-09T13:24:54.011Z","comments":true,"path":"2018/03/14/unity笔记/","link":"","permalink":"http://sgclzqq.com/2018/03/14/unity笔记/","excerpt":"","text":"代码中改变Light组件的ShadowType属性light.shadows=LightShadow.Hard; //LightShadow.Soft,LightShadow.None","categories":[{"name":"unity笔记","slug":"unity笔记","permalink":"http://sgclzqq.com/categories/unity笔记/"}],"tags":[{"name":"unity笔记","slug":"unity笔记","permalink":"http://sgclzqq.com/tags/unity笔记/"}]}]}