<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>test</title>
      <link href="/2018/04/17/test/"/>
      <content type="html"><![CDATA[<p>ggsgsfdg</p>]]></content>
      
      <categories>
          
          <category> 测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Unity组件本地映射</title>
      <link href="/2018/04/09/Unity%E7%BB%84%E4%BB%B6%E6%9C%AC%E5%9C%B0%E6%98%A0%E5%B0%84/"/>
      <content type="html"><![CDATA[<ul><li><a href="#TextMesh组件本地映射">TextMesh组件本地映射</a></li><li><a href="#Light组件本地映射">Light组件本地映射</a></li></ul><p>通过JsonNet插件将Unity组件的属性值保存到本地的Json文件中，便于重新加载数据，恢复组件属性值，达到保存组件状态的目标。</p><a id="more"></a><h2 id="TextMesh组件本地映射"><a href="#TextMesh组件本地映射" class="headerlink" title="TextMesh组件本地映射"></a>TextMesh组件本地映射</h2><p>TextMesh本地映射</p><pre><code class="CSharp">public JToken GenerateJToken(Component component)        {            TextMesh e = component as TextMesh;            if (!e) return null;            JObject jo = new JObject();            jo.Add(&quot;type&quot;, typeof(TextMesh).FullName);            jo.Add(&quot;text&quot;, e.text);            jo.Add(&quot;offsetZ&quot;, e.offsetZ);            jo.Add(&quot;characterSize&quot;, e.characterSize);            jo.Add(&quot;lineSpacing&quot;, e.lineSpacing);            jo.Add(&quot;anchor&quot;, (int) e.anchor);            jo.Add(&quot;alignment&quot;, (int)e.alignment);            jo.Add(&quot;tabSize&quot;, e.tabSize);            jo.Add(&quot;fontSize&quot;, e.fontSize);            jo.Add(&quot;fontStyle&quot;, (int)e.fontStyle);            jo.Add(&quot;richText&quot;, e.richText);            var color = e.color;            var colorStr = string.Format(&quot;{0},{1},{2},{3}&quot;, color.r, color.g, color.b, color.a);            jo.Add(&quot;color&quot;, colorStr);            return jo;        }</code></pre><p>TextMesh加载恢复</p><pre><code class="CSharp">public void ApplyJToken(Component component, JToken jt)        {            TextMesh e = component as TextMesh;            if (!e) return;            e.text = (string) jt[&quot;text&quot;];            e.offsetZ = (float) jt[&quot;offsetZ&quot;];            e.characterSize = (float) jt[&quot;characterSize&quot;];            e.lineSpacing = (float) jt[&quot;lineSpacing&quot;];            e.anchor=(TextAnchor)(int)jt[&quot;anchor&quot;];            e.alignment = (TextAlignment) (int) jt[&quot;alignment&quot;];            e.tabSize = (float) jt[&quot;tabSize&quot;];            e.fontSize = (int) jt[&quot;fontSize&quot;];            e.fontStyle = (FontStyle) (int) jt[&quot;fontStyle&quot;];            e.richText = (bool) jt[&quot;richText&quot;];            FrameCount.CountdownCallBack(1, () =&gt;            {                e.font = Font.CreateDynamicFontFromOSFont(&quot;Arial&quot;, 12);                if (e.font != null) e.transform.GetComponent&lt;MeshRenderer&gt;().sharedMaterial = e.font.material;            });            var colorStr= (string)jt[&quot;color&quot;];            string[] str = colorStr.Split(&#39;,&#39;);            Color color = new Color(float.Parse(str[0]), float.Parse(str[1]), float.Parse(str[2]), float.Parse(str[3]));            e.color = color;        }</code></pre><h2 id="Light组件本地映射"><a href="#Light组件本地映射" class="headerlink" title="Light组件本地映射"></a>Light组件本地映射</h2><p>Light本地映射</p><pre><code class="CSharp">public JToken GenerateJToken(Component component)        {            Light e = component as Light;            if (!e) return null;            JObject jo = new JObject();            jo.Add(&quot;type&quot;, typeof(Light).FullName);            jo.Add(&quot;lightType&quot;, (int) e.type);            if (e.type == LightType.Point || e.type == LightType.Spot)            {                jo.Add(&quot;range&quot;, e.range);            }            if (e.type == LightType.Spot)            {                jo.Add(&quot;spotAngle&quot;, e.spotAngle);            }            var color = e.color;            var colorStr = string.Format(&quot;{0},{1},{2},{3}&quot;, color.r, color.g, color.b, color.a);            jo.Add(&quot;color&quot;, colorStr);            jo.Add(&quot;intensity&quot;, (float) e.intensity);            jo.Add(&quot;shadowType&quot;, (int) e.shadows);            jo.Add(&quot;strength&quot;, e.shadowStrength);            jo.Add(&quot;shadowResolution&quot;, (int) e.shadowResolution);            jo.Add(&quot;bias&quot;, e.shadowBias);            jo.Add(&quot;normalBias&quot;, e.shadowNormalBias);            jo.Add(&quot;nearPlane&quot;, e.shadowNearPlane);            jo.Add(&quot;renderMode&quot;, (int)e.renderMode);            jo.Add(&quot;mask&quot;, (int) e.cullingMask);            return jo;        }</code></pre><p>Light属性恢复</p><pre><code class="CSharp">public void ApplyJToken(Component component, JToken jt)        {            Light e = component as Light;            if (!e) return;            e.type = (LightType)(int)jt[&quot;lightType&quot;];            if (e.type == LightType.Point || e.type == LightType.Spot)            {                e.range = (float)jt[&quot;range&quot;];            }            if (e.type == LightType.Spot)            {                e.spotAngle = (float) jt[&quot;spotAngle&quot;];            }            var colorStr = (string)jt[&quot;color&quot;];            string[] str = colorStr.Split(&#39;,&#39;);            Color color = new Color(float.Parse(str[0]), float.Parse(str[1]), float.Parse(str[2]), float.Parse(str[3]));            e.color = color;            e.intensity = (float) jt[&quot;intensity&quot;];            e.shadows = (LightShadows) (int) jt[&quot;shadowType&quot;];            e.shadowStrength = (float) jt[&quot;strength&quot;];            e.shadowResolution = (LightShadowResolution)(int) jt[&quot;shadowResolution&quot;];            e.shadowBias = (float) jt[&quot;bias&quot;];            e.shadowNormalBias = (float) jt[&quot;normalBias&quot;];            e.shadowNearPlane = (float) jt[&quot;nearPlane&quot;];            e.renderMode = (LightRenderMode) (int) jt[&quot;renderMode&quot;];            e.cullingMask = (int) jt[&quot;mask&quot;];        }</code></pre>]]></content>
      
      
        <tags>
            
            <tag> Unity笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>unity笔记</title>
      <link href="/2018/03/14/unity%E7%AC%94%E8%AE%B0/"/>
      <content type="html"><![CDATA[<h3 id="代码中改变Light组件的ShadowType属性"><a href="#代码中改变Light组件的ShadowType属性" class="headerlink" title="代码中改变Light组件的ShadowType属性"></a>代码中改变Light组件的ShadowType属性</h3><pre><code class="CSharp">light.shadows=LightShadow.Hard; //LightShadow.Soft,LightShadow.None</code></pre>]]></content>
      
      <categories>
          
          <category> unity笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> unity笔记 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
